'''
This script produces two radial convergence graphs (aka chord graphs) for Sobol
Sensitivity Analysis results in a dictionary format. It can directly work with 
Sobol results produced by Rhodium. 
For Sobol results generated by SALib, convert first, as in salib_example.py. 
The script will produce one graph with straight lines and one with curved lines 
(parabolas).

Written by Antonia Hadjimichael (https://github.com/antonia-had) based off code
by Enrico Ubaldi (https://github.com/ubi15/).
The script was written and tested in Python 3.6 and 3.7. 
'''
import os
import networkx as nx
import numpy as np
import itertools
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns

def drawgraphs(SAresults):
    
    '''
    Define some plot tweak settings.
    '''    
    
    # 나중에 칼라맵 추가할 것 
    fs = 12                 # label font size 
    
    # cubehelix gradient 
    # http://davidjohnstone.net/pages/cubehelix-gradient-picker
    # cmap = sns.cubehelix_palette(as_cmap=True, reverse=False,
    #                              start=0, rot=0.5, 
    #                              gamma=0.8, hue=0.85, 
    #                              light=0.8, dark=0.0)
    cmap = sns.cubehelix_palette(as_cmap=True, 
                                 start=2.4, rot=0.0)
    cmap2 = sns.cubehelix_palette(as_cmap=True, 
                                  start=2.4, rot=0.0, gamma=0.8)    # node color 
    
    # cmap2 = plt.cm.Greens     # colormap
    node_c = '#98B5E2'      # node color, default: '#98B5E2'
    node_line_c = 'k'       # node line color, default: '#1A3F7A'
    line_c = cmap(0.4)      # 2nd order line color, default: '#2E5591'
    font_c = 'k'            # font color, defulat: '#0B2D61' 노드 안쪽이면 흰색으로 해도 될듯 
    
    from_node = 1.00    # move label position from node center, default=1.1
    from_node2 = 1.0   # move label position from node center, default=1.01
    from_node_curve1 = 1.0   # move label position from node center, for curve networks
    from_node_curve2 = 1.0   # move label position from node center, for curve networks
    
    node_size_fix = 250     # fixed node size
    node_size_frac = 0.1    # node size adjust fraction (%)
    node_line_frac = 0.5    # node line width fraction (%)
    edge_width_fix = 1.5      # fixed node edge width
    
    # Set min index value, for the effects to be considered significant
    # 그래프에 표시하기 위한 threshold SI       
    index_threshold = 0.00025
    
    
    '''
    Define some general layout settings.
    '''
    node_size_min = 18 # Max and min node size, default [15,25]
    node_size_max = 25
    border_size_min = 0.75 # Max and min node line thickness, default [1,8]
    border_size_max = 4.5
    edge_width_min = 1 # Max and min S2 line thickness (2nd order lines), default [1,8]
    edge_width_max = 6
    
    # Max and min distance of the edge from the center of the circle
    # min 이 커지면 곡률이 더 커짐 (오목해짐) 
    # max 가 커지면 더 휨, 작을 수록 노드 잇는 선들 직선에 가까움 
    edge_distance_min = 0.05     # default 0.1
    edge_distance_max = 0.4     # Only applicable to the curved edges, default 0.6
    
    # Get list of parameters
    parameters = list(SAresults['S1'].keys())
    
    # To make Latex labels
    params_latex = ['$'+i+'$' for i in parameters]
    
    
    #%% predefined functions
    
    '''
    Set up some variables and functions that will facilitate drawing circles and 
    moving items around.
    '''
    # Define circle center and radius
    center = [0.0, 0.0]     # circle center coordinate
    radius = 1.0            # radius of circle
    
    # centimeters to inch
    def cm2in(value):
        return value/2.54
    
    # Function to get distance between two points
    def distance(p1,p2):
        return np.sqrt(((p1 - p2)**2).sum())
    
    # Function to get middle point between two points
    def middle(p1,p2):
        return (p1 + p2)/2
    
    # Function to get the vertex of a curve between two points
    def vertex(p1,p2,cen_p):
        mid_p = middle(p1,p2)   # middle point between p1 and p2 
        curve_dir = cen_p - mid_p # center point - middle point
        return mid_p + curve_dir*(edge_distance_min + edge_distance_max*(1-distance(mid_p,cen_p)/distance(cen_p,p1)))
    
    # Function to get the angle of the node from the center of the circle
    def angle(node_p,cen_p):
        # Get x and y distance of point from center
        [dx,dy] = node_p - cen_p 
        # 원을 4개의 파이로 나눠서 어디에 위치해있는가를 if 문으로 판단함. 
        if dx == 0:     # If point on vertical axis (same x as center),  노드좌표가 x==0이면
            if dy>0:    # If point is on positive vertical axis, 노드의 좌표가 중심 오른 x==0, y>0
                return np.pi/2.0
            else: # If point is on negative vertical axis, 노드의 좌표가 중심 왼쪽 x==0, y<0
                return np.pi*3.0/2.0
        elif dx>0: # If point in the right quadrants, 
            if dy>=0: # If point in the top right quadrant, 노드 좌표가 오른쪽 위 
                return np.arctan(dy/dx)
            else: # If point in the bottom right quadrant, 노드 좌표가 오른쪽 아래 
                return 2*np.pi+np.arctan(dy/dx)
        elif dx<0: # If point in the left quadrants, 노드 좌표가 왼쪽 위아래 
            return np.pi+np.arctan(dy/dx)
        
    #%% figure node, border, color, line weight
    '''
    First, set up graph with all parameters as nodes and draw all second order (S2)
    indices as edges in the network. For every S2 index, we need a Source parameter,
    a Target parameter, and the Weight of the line, given by the S2 index itself. 
    '''
    # possible combinations of parameters using list(itertools.combinations(parameters, 2))
    param_combs = [list(cen_p) for cen_p in list(itertools.combinations(parameters, 2))]
    
    # [['x1', 'x2'], ['x1', 'x3'], ['x2', 'x3']] 를 list(zip()) 을 이용해서 [('x1', 'x1', 'x2'), ('x2', 'x3', 'x3')] 로 변환 
    # 시작점이 Sources ('x1', 'x1', 'x2'), 종착점이 Targets ('x2', 'x3', 'x3')이 타겟으로 페어를 이루게 됨 
    Sources = list(list(zip(*param_combs))[0])
    Targets = list(list(zip(*param_combs))[1])
    
    # Sometimes computing errors produce negative Sobol indices. 
    # The following reads in all the indices and also ensures they are between 0 and 1.
    # for 문으로 세컨오더 S2의 소스와 타겟의 페어를 선택해서 선의 Weights (S2값) 값이 반드시0~1이 되도록 함 
    Weights = [max(min(x, 1), 0) for x in [SAresults['S2'][Sources[i]][Targets[i]] for i in range(len(Sources))]]
    # 세컨오더 선 굵기 Weights의 최소값이 threshold보다 작으면 0이 되도록 함. 
    Weights = [0 if x<index_threshold else x for x in Weights]
    
    # Set up graph
    G = nx.Graph() # networkx 그래프 함수 콜
    
    # Draw 2nd order lines with appropriate weight
    # 선의 출발점 Sources, 도착점 Taegets, 선의 굵기 Weights를 묶어서 for loop
    for s, t, weight in zip(Sources, Targets, Weights):
        ##################### convert to latex label 
        s = '$'+s+'$'
        t = '$'+t+'$'
        #####################
        G.add_edges_from([(s,t)], w=weight)
    
    # Generate dictionary of node postions in a circular layout, 노드들의 xy 좌표
    node_xy = nx.circular_layout(G)
    
    
    
    '''
    Normalize node size according to first order (S1) index. First, read in S1 indices,
    ensure they're between 0 and 1 and normalize them within the max and min range
    of node sizes.
    Then, normalize edge thickness according to S2. 
    '''
    # Node size
    # Si 사이즈가 반드시0~1이 되도록 함 
    first_order = [max(min(x, 1), 0) for x in [SAresults['S1'][key] for key in SAresults['S1']]]
    # threshold 이하이면 0으로함 
    first_order = [0 if x<index_threshold else x for x in first_order] 
    # 설정한 최소노드크기에 1.xx 곱해서 노드사이즈 결정 
    # (node_size_max-node_size_min): 설정노드범위,  si/max(first_order): Si레이시오 
    node_size = [node_size_min*(1 + (node_size_max - node_size_min)*si/max(first_order)) for si in first_order]
    
    # Node border thickness
    # ST 사이즈가 반드시0~1이 되도록 함 
    total_order = [max(min(x, 1), 0) for x in [SAresults['ST'][key] for key in SAresults['ST']]]
    # threshold 이하이면 0으로함 
    total_order = [0 if x<index_threshold else x for x in total_order]
    # 설정한 최소노드크기에 1.xx 곱해서 노드사이즈 결정 
    # (border_size_max-border_size_min): 설정 노드라인 굵기 범위,  sti/max(total_order): STi레이시오 
    border_size = [border_size_min*(1 + (border_size_max - border_size_min)*sti/max(total_order)) for sti in total_order]
    
    # Edge thickness
    # 세컨오더 Weights의 비율에 기반해서 연결 선의 굵기 결정  
    edge_width = [edge_width_min*((edge_width_max - edge_width_min)*s2/max(Weights)) for s2 in Weights]
    
    '''
    Draw network. This will draw the graph with straight lines along the edges and 
    across the circle. 
    '''    
    
    # 1) node size vary (first order SI)
    # nx.draw_networkx_nodes(G, node_xy, 
    #                        node_size=node_size, node_color=node_c, 
    #                         edgecolors=node_line_c, linewidths = border_size)
    
    # 2) node size fixed varying node colors (first order SI)
    nx.draw_networkx_nodes(G, node_xy, 
                           node_size=node_size_fix, 
                           node_color=node_size, 
                           cmap=cmap,
                           edgecolors='k', 
                           linewidths = edge_width_fix)
    
    params_list = list(node_xy.keys())
    
    # node label color cumstomize
    node_s = np.array(node_size)        # list to array 
    print(node_s)   # 노드 사이즈 최소값 확인활것 
    norm_node_s = (node_s-np.min(node_s)*0.8)/max(node_s)    # normailized node size 최대값이 검정색이 되지 않도록 약간 빼줄것 
    # norm = mcolors.Normalize(vmin=0, vmax=max(node_s))
    node_rgba = cmap2(norm_node_s)   # node color rgba based on node size
    # summation of normalized node rgb
    # if (red*0.299 + green*0.587 + blue*0.114) > 186 use #000000 else use #ffffff] 
    sum_node_rgb = node_rgba[:,0]*0.299 + node_rgba[:,1]*0.587 + node_rgba[:,2]*0.114 
    label_color = ['k' if i>0.65 else 'w' for i in sum_node_rgb]    # threshold 0.65
    

    # line (second order SI) 
    nx.draw_networkx_edges(G, node_xy, width=edge_width, edge_color=line_c, alpha=0.7)
    
    # node parameter label
    # 만약 노드 안쪽으로 보낼 거면 흰색으로 해도 될 듯 
    # if (red*0.299 + green*0.587 + blue*0.114) > 186 use #000000 else use #ffffff
    names = nx.draw_networkx_labels(G, node_xy, 
                                    font_size=fs, 
                                    font_color=font_c, 
                                    font_family='sans-serif')
    

        
        # ax.plot(node_xy[node_key][0], node_xy[node_key][1],
        #         'o', c = node_rgba[i], 
        #         markersize = node_size_fix*node_size_frac, 
        #         markeredgecolor = node_line_c, markeredgewidth = border_size[i]) 
    
    # names라는 networkx 오브젝트에 node_key: label좌표, text: label이 들어있음 
    for node_key, text in names.items(): 
        print(text)
        position = (radius*from_node*np.cos(angle(node_xy[node_key],center)), radius*from_node*np.sin(angle(node_xy[node_key],center)))
        text.set_position(position) # 노드 중심의 텍스트를 이동 
        text.set_clip_on(False)     # 틀 밖으로 튀어 나간 부분 삭제  
        
    plt.gcf().set_size_inches(cm2in(10), cm2in(10))  # Make figure a square
    plt.axis('off')                 # figure spine 지움  
    
    
    #%% curved network coordinates 
    
    '''
     We can now draw the network with curved lines along the edges and across the circle.
     Calculate all distances between 1 node and all the others (all distances are 
     the same since they're in a circle). We'll need this to identify the curves 
     we'll be drawing along the perimeter (i.e. those that are next to each other).
     '''
     
    # 첫번째 조드 좌표  node_xy[list(G.nodes())[0]] 랑 다른 노드 좌표 node_xy[n] distance 함수로 거리 구해서 최소가 되는 것만 min으로 취함 
     # round 왜 취하는 건지. 
    # min_distance = round(min([distance(node_xy[list(G.nodes())[0]],node_xy[n]) for n in list(G.nodes())[1:]]), 1)
    min_distance = min([distance(node_xy[list(G.nodes())[0]],node_xy[n]) for n in list(G.nodes())[1:]])
    
    # Figure to generate the curved edges between two points
    def xy_edge(p1,p2): # Point 1, Point 2
        mid_p = middle(p1,p2) # Get middle point between the two nodes
        # If the middle of the two points falls very close to the center, 
        # then the line between the two points is simply straight
        if distance(mid_p,center)<1e-6:
            xpr = np.linspace(p1[0], p2[0], 100)
            ypr = np.linspace(p1[1], p2[1], 100)
            
        # If the distance between the two points is the minimum (i.e. they are next to each other), 
        # draw the edge along the perimeter 
        # 두 노드 포인사트 이 거리에 따라서 페리미터로 연결하기도 함     
        elif distance(p1, p2)<=min_distance:
            # Get angles of two points
            p1_angle = angle(p1, center)
            p2_angle = angle(p2, center)
            # Check if the points are more than a hemisphere apart
            # np.linspace default num=50
            if max(p1_angle, p2_angle)-min(p1_angle, p2_angle) > np.pi:
                radi = np.linspace(max(p1_angle, p2_angle) - 2*np.pi, min(p1_angle, p2_angle))
            else:
                radi = np.linspace(min(p1_angle, p2_angle), max(p1_angle, p2_angle))
            xpr = radius*np.cos(radi) + center[0] # x points
            ypr = radius*np.sin(radi) + center[1] # y points 
        # Otherwise, draw curve (parabola)
        else: 
            edge_vertex = vertex(p1,p2,center)
            a = distance(edge_vertex, mid_p)/((distance(p1,p2)/2)**2)
            yp = np.linspace(-distance(p1, p2)/2, distance(p1, p2)/2, 100)
            xp = a*(yp**2)
            xp += distance(center, edge_vertex)
            theta_m = angle(middle(p1, p2), center)
            xpr = np.cos(theta_m)*xp - np.sin(theta_m)*yp # x points
            ypr = np.sin(theta_m)*xp + np.cos(theta_m)*yp # y points
            xpr += center[0]
            ypr += center[1]
        return xpr, ypr

#%% draw curved polot       
    '''
    Draw network. This will draw the graph with curved lines along the edges and 
    across the circle. 
    '''
    
    # node color (S1)
    nc = np.abs(first_order/np.max(first_order) -0.05) # 제일 진한색이 검정이 안되게 하기 
    
    # curved radial plot figure 
    fig, axe = plt.subplots(1, 1, sharex=False, sharey=False, figsize=(cm2in(12),cm2in(12)), 
                                facecolor='w', edgecolor='k', squeeze=True)
        
    axe.set_xlim(-1.2, 1.2)
    axe.set_ylim(-1.2, 1.2)
    
    
    a = np.array(list(SAresults['S1'].values()))
    a = a/max(a)
    
    # lines for 2nd order SI 
    for i, nodes_pair in enumerate(G.edges()):
        x, y = xy_edge(node_xy[nodes_pair[0]], node_xy[nodes_pair[1]])
        # print(x)
        # print(y)
        axe.plot(x, y,'-', 
                 c = line_c, 
                 lw = edge_width[i], alpha=0.6)
        
    # 1) varying node size and node line width       
    # for i, n in enumerate(G.nodes()):
    #     axe.plot(node_xy[n][0],node_xy[n][1], 'o', c=node_c, markersize=node_size[i]*node_size_frac, 
    #             markeredgecolor = node_line_c, markeredgewidth = border_size[i]*node_line_frac)
        
    # 2) Fixed node size and node line width       
    for i, node_key in enumerate(G.nodes()):
        axe.plot(node_xy[node_key][0], node_xy[node_key][1],
                'o', c = cmap2(nc[i]), 
                markersize = node_size_fix*node_size_frac, 
                markeredgecolor = node_line_c, 
                markeredgewidth = border_size[i])    
        
        # axe.scatter(node_xy[node_key][0],node_xy[node_key][1],
        #            marker='o',s=node_size_fix*node_size_frac,     
        #             c = cmap(a[i]), cmap=cmap,
        #             norm=None, 
        #             linewidths = border_size[i], edgecolors='k', 
        #             verts=None, label=node_key, alpha=1.0)
        
    # node label
    # for i, node_key in enumerate(G.nodes()):
    #     if node_size[i]<100:
    #         position = (radius*from_node_curve1*np.cos(angle(node_xy[node_key],center)), radius*from_node_curve1*np.sin(angle(node_xy[node_key],center)))
    #     else:
    #         position = (radius*from_node_curve2*np.cos(angle(node_xy[node_key],center)), radius*from_node_curve2*np.sin(angle(node_xy[node_key],center)))
    #     plt.annotate(node_key, position, 
    #                  fontsize = fs, color=label_color[i], family='sans-serif')         
        
    

    # 좌표는 맨 오른쪽 것부터 반시계방향으로 순서.     
    # offset of x, y coordinates     
    off_x = np.ones([len(parameters), 1])*(-0.04)
    off_y = np.ones([len(parameters), 1])*(-0.02)
    np.shape(off_x)
    # small corrections 
    correct_x = [[0.001], [-0.001], [0], [0], [-0.005], [0.005]]
    correct_y = [[0], [-0.005], [-0.005], [0], [0], [0]]
    # final coordinates
    off_x[:len(correct_x)] -= correct_x
    off_y[:len(correct_y)] -= correct_y
    
    # position of annotation
    pos = np.zeros([len(parameters), 2])
    
    # draw annotation
    for i, node_key in enumerate(G.nodes()):   
        pos[i,:] = [node_xy[node_key][0] + off_x[i], node_xy[node_key][1] + off_y[i]]
        print(np.sqrt(pos[i,0]**2 + pos[i,1]**2))
        plt.annotate(node_key, pos[i,:],
                      fontsize = fs, family='sans-serif',
                      color = label_color[i]) 
        
        
    axe.axis('off')    
    fig.tight_layout()
    # my_path = os.getcwd() + '\plot\ '
    # figname = 'Radial_convergence_plot' 
    # plt.savefig(my_path+figname+'.png', dpi=600)